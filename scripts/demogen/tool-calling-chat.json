{
  "metadata": {
    "complexity": 2,
    "description": "A simple example of a tool-calling chatbot that uses a getWeather tool with fake data and a rollDice tool that renders a red die with pips. This demo uses tool calling.",
    "id": "tool-calling-chat",
    "name": "Tool Calling Chatbot",
    "tags": [
      "tool-calling",
      "chat"
    ]
  },
  "plan": "Okay, here's the implementation plan for the \"Tool Calling Chatbot\" demo:\n\n**1. Excitement Factor:**\n\n*   **Interactive Tool Use:** Developers will be excited to see how the LLM can intelligently choose between different tools (weather and dice rolling) based on the user's input. The ability to define custom tools and have the model decide when to use them is a powerful concept.\n*   **Visual Tool Responses:** The demo will showcase how to not just get text back from tool calls, but also render a specific visual UI in response. This will demonstrate the flexibility of tool-calling and its potential for richer user interfaces.\n*   **Clear Code Example:** This demo will provide a simple, self-contained example of setting up and using a tool-calling chatbot. The focus will be on showcasing the core feature of tool calling and its visual representation of responses, making it easy for developers to understand and adapt.\n\n**2. UI Design:**\n\n*   **Single Column Layout:** The UI will be a single vertical column, ideal for a tall narrow layout.\n*   **Chat Interface:**\n    *   A simple chat input box at the bottom for users to type messages.\n    *   A display area above the input box to show the conversation history.\n    *   Each message in the history will have a clear indication of who sent it (user or bot).\n*  **Tool Response Rendering:**\n   *  **Dice Roll:** If the bot responds with a `rollDice` tool response, the UI should render a large, red die graphic with the number of pips corresponding to the roll. The die should use a component that can visually represent the die face, perhaps using SVG.\n   *  **Weather:** If the bot responds with a `getWeather` tool response, the UI should display the weather information including the temperature and a weather condition icon (e.g., sunny, cloudy, rainy) from lucide.\n*   **Visual Clarity:** Use clear typography and spacing to ensure the conversation is easy to follow. Use `shadcn/ui` components whenever possible.\n*   **No frills:** keep it basic. We want to show the tool calling, not a fancy UI.\n\n**3. Configuration:**\n\n*   **System Message:** The user should be able to configure the system message that is used to initialize the chat. This will allow the user to experiment with different chatbot personalities and behaviors. The config should be rendered below the app, and should not take up too much visual space.\n\n**4. Server-Side API Endpoint (`api/route.ts`):**\n\n*   **Initialization:**\n    *   Import necessary Genkit modules and the `@genkit-ai/googleai` plugin.\n    *   Create a Genkit instance with the desired model (e.g., `gemini15Flash`).\n    *   Define the `getWeather` tool using `ai.defineTool()`. This tool will take a `location` as input and return a string containing the temperature and conditions (e.g., \"The current weather in New York is 70F and sunny\"). The data returned here will be fake.\n    *   Define the `rollDice` tool using `ai.defineTool()`. This tool will have no input, and return a number between 1 and 6.\n*  **Chat Handling**\n    *   The `route.ts` should have a POST handler that accepts a `messages` array from the UI, and a `systemMessage` from the config.\n    *   Create a new chat object with `ai.chat({system: systemMessage, tools: [getWeather, rollDice]})` using the configured system message.\n    *   Call `chat.send()` with the latest user message.\n    *   Return the resulting `chat.send()` response, which will contain the tool call (if it exists) or the LLM message and should be returned as JSON.\n    *   Do not stream the data. A simple API call is fine here.\n*   **Error Handling:** Include basic error handling for API calls and tool executions.\n\n**Detailed Steps:**\n\n1.  **Project Setup:** Ensure a Next.js project is created and all dependencies are installed, as per the \"Technology Stack and Demo Structure\" section.\n2.  **`app/tool-calling-chat/page.tsx`:** Create a basic page component that renders the `app.tsx` and `config.tsx` client components.\n3.  **`app/tool-calling-chat/app.tsx`:**\n    *   Create the chat UI layout using shadcn/ui components such as `Input` and a scrollable div to contain the message history.\n    *   Add a function to send a message to the server-side API endpoint (`/api/route.ts`). This function should update the UI state with the user message and the bot's response.\n    *   Implement the logic to detect if a tool response is present in the bot's message and to render a visual die or weather data depending on the tool name.\n    *    Implement the visual die component using `react-icons` or similar to create a basic red die with pips.\n    *    Implement weather icon rendering with `lucide-react`\n4.  **`app/tool-calling-chat/config.tsx`:**\n    *   Create a form to display and update the system message. It should allow editing the system message via a simple `textarea` input.\n    *   The form should call an update function to send the updated system message to the `app.tsx` component (which can handle updating state and communicating with the backend).\n5.  **`app/tool-calling-chat/api/route.ts`:**\n    *   Implement the server-side logic as described in the \"Server-Side API Endpoint\" section above.\n6.  **`app/tool-calling-chat/README.md`**:\n     *   Include the demo description and a short explanation of what the user can do with the demo.\n7. **Styling:** Use Tailwind for basic styling of the components. The focus is on clear structure and readability, not complex UI.\n\nThis detailed plan should be sufficient for another developer to pick up and implement the demo. The focus is on showcasing the core tool-calling functionality with a simple and engaging UI.\n",
  "readme": "# Tool Calling Chatbot\n\nThis demo showcases a simple chatbot that utilizes Genkit's tool calling feature. The chatbot is capable of responding to user prompts by using two defined tools: `getWeather`, which simulates fetching weather data, and `rollDice`, which simulates rolling a six-sided die. When the bot uses the `rollDice` tool, it will render a red die with the appropriate number of pips. When the bot uses the `getWeather` tool, it will return a temperature and weather condition with an appropriate icon from lucide.  This demo allows you to configure the system message, allowing you to experiment with different bot personas and behaviors.\n\n## Things to Try\n\n- Ask the bot for the weather in a specific location.\n- Ask the bot to roll a die.\n- Combine requests, for example \"What's the weather like, and then roll a die\".\n- Change the system message to influence the bot's behavior, for example \"You are a helpful assistant who likes to use tools\".",
  "files": [
    {
      "ext": "ts",
      "path": "api/route.ts",
      "content": "import { genkit, z } from \"genkit\";\nimport { gemini15Flash, googleAI } from \"@genkit-ai/googleai\";\nimport genkitEndpoint from \"@/lib/genkit-endpoint\";\n\nconst ai = genkit({\n  plugins: [googleAI()],\n  model: gemini15Flash,\n});\n\nconst getWeather = ai.defineTool(\n  {\n    name: \"getWeather\",\n    description: \"Gets the current weather in a given location\",\n    inputSchema: z.object({\n      location: z.string().describe(\"The location to get the current weather for\"),\n    }),\n    outputSchema: z.object({\n      temperature: z.number().describe(\"The current temperature in degrees Fahrenheit\"),\n      condition: z.enum([\"sunny\", \"cloudy\", \"rainy\", \"snowy\"]).describe(\"The current weather condition\"),\n    }),\n  },\n  async ({ location }) => {\n    // Fake weather data\n    const randomTemp = Math.floor(Math.random() * 30) + 50; // Random temp between 50 and 80\n    const conditions = [\"sunny\", \"cloudy\", \"rainy\", \"snowy\"];\n    const randomCondition = conditions[Math.floor(Math.random() * conditions.length)];\n\n    return { temperature: randomTemp, condition: randomCondition };\n  }\n);\n\n\nconst rollDice = ai.defineTool(\n  {\n    name: \"rollDice\",\n    description: \"Rolls a six-sided die\",\n    inputSchema: z.object({}),\n    outputSchema: z.number().int().min(1).max(6),\n  },\n  async () => {\n    return Math.floor(Math.random() * 6) + 1;\n  }\n);\n\nexport const POST = genkitEndpoint(\n  {\n    schema: z.object({\n      system: z.string(),\n      messages: z.array(\n        z.object({\n          role: z.enum([\"user\", \"assistant\"]),\n          content: z.string(),\n        })\n      ),\n      prompt: z.string(),\n    }),\n  },\n  async ({ system, messages, prompt }) => {\n    const chat = ai.chat({ system, tools: [getWeather, rollDice] });\n    \n    // send all of the history and the new message to the chat\n    const response = await chat.send({messages, prompt});\n    \n    return response;\n\n  }\n);"
    },
    {
      "ext": "tsx",
      "path": "config.tsx",
      "content": "\"use client\";\n\nimport { Card, CardContent } from \"@/components/ui/card\";\nimport { Textarea } from \"@/components/ui/textarea\";\nimport DemoConfig from \"@/lib/demo-config\";\nimport { Label } from \"@radix-ui/react-label\";\nimport { useContext } from \"react\";\n\nexport default function ToolCallingChatbotConfig() {\n  const { config, setConfig } = useContext(DemoConfig);\n\n  return (\n    <Card>\n      <CardContent>\n        <Label htmlFor=\"form-system\" className=\"mt-3 mb-2 block\">\n          Custom System Message\n        </Label>\n        <Textarea\n          placeholder=\"You are a helpful assistant. Try to answer the user's queries to the best of your ability.\"\n          value={config?.system}\n          id=\"form-system\"\n          name=\"system\"\n          onInput={(e) => {\n            setConfig?.({ system: (e.target as HTMLTextAreaElement).value });\n          }}\n        />\n      </CardContent>\n    </Card>\n  );\n}"
    },
    {
      "ext": "tsx",
      "path": "app.tsx",
      "content": "\"use client\";\nimport Chat from \"@/components/chat\";\nimport { LucideIcon, Sun, Cloud, CloudRain, CloudSnow } from \"lucide-react\";\n\nfunction WeatherResponse({\n  temperature,\n  condition,\n}: {\n  temperature: number;\n  condition: \"sunny\" | \"cloudy\" | \"rainy\" | \"snowy\";\n}) {\n  let icon: LucideIcon = Sun;\n  switch (condition) {\n    case \"cloudy\":\n      icon = Cloud;\n      break;\n    case \"rainy\":\n      icon = CloudRain;\n      break;\n    case \"snowy\":\n      icon = CloudSnow;\n      break;\n  }\n\n  return (\n    <div className=\"flex items-center gap-2\">\n      <span className=\"text-xl\">{temperature}°F</span>\n      <span className=\"text-xl\">{icon}</span>\n    </div>\n  );\n}\n\nfunction DiceResponse({ output }: { output: number }) {\n  const pips = Array.from({ length: output }, (_, i) => (\n    <span key={i} className=\"h-2 w-2 rounded-full bg-white\"></span>\n  ));\n\n  return (\n    <div className=\"relative h-12 w-12 flex items-center justify-center rounded-md bg-red-500\">\n      <div className=\"absolute flex flex-wrap content-around h-8 w-8 items-center justify-center gap-1\">\n          {pips}\n      </div>\n    </div>\n  );\n}\n\n\nexport default function ToolCallingChatbotApp() {\n  return (\n    <Chat\n      endpoint=\"/tool-calling-chat/api\"\n      renderPart={(part) => {\n        if (part.toolResponse?.name === \"getWeather\")\n          return <WeatherResponse {...part.toolResponse.output} />;\n        if (part.toolResponse?.name === \"rollDice\")\n          return <DiceResponse output={part.toolResponse.output} />;\n        return null;\n      }}\n    />\n  );\n}"
    },
    {
      "ext": "ts",
      "path": "page.tsx",
      "content": "import Demo from \"@/components/demo\";\nimport ToolCallingChatbotConfig from \"./config\";\nimport ToolCallingChatbotApp from \"./app\";\n\nexport default async function Page() {\n  return (\n    <Demo\n      name=\"tool-calling-chat\"\n      title=\"Tool Calling Chatbot\"\n      Config={ToolCallingChatbotConfig}\n    >\n      <ToolCallingChatbotApp/>\n    </Demo>\n  );\n}"
    }
  ]
}