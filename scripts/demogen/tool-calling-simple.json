{
  "metadata": {
    "complexity": 2,
    "description": "A simple example of tool calling with a getWeather tool that fakes its data and a rollDice tool that rolls a six-sided die. The UI renders a rollDice tool response as a red die with pips and weather tool response should include temperature, sunny/cloudy/etc and should render in the ui with icons from lucide.",
    "id": "tool-calling-simple",
    "name": "Simple Tool Calling",
    "tags": [
      "tool-calling"
    ]
  },
  "plan": "Okay, here's the implementation plan for the \"Simple Tool Calling\" demo:\n\n**Excitement Factor:**\n\n*   This demo showcases how to give an LLM access to custom functionality via tool calling. Developers will see how they can extend the capabilities of an LLM beyond its pre-trained knowledge.\n*   The visual representation of tool calls (dice roll and weather) adds a tangible, fun element, making the concept more easily graspable.\n*   The ability to see the actual data returned from the tools will make it clear how this works without needing to dig through debug output.\n\n**UI Design:**\n\nThe UI will consist of the following elements:\n\n1.  **Text Input:** A `textarea` using the `shadcn/ui` component to allow the user to input a prompt for the LLM. It should have a clear placeholder like \"Ask a question about the weather or roll a dice!\".\n2.  **Submit Button:** A `Button` component that triggers the LLM request when clicked. It should say something like \"Send\".\n3.  **Response Area:** This area will display the LLM's responses. It will have a couple of possible elements:\n    *   **Text Response:** Standard LLM text output will be displayed in a normal `<div>`.\n    *   **Dice Tool Response:** When the `rollDice` tool is called, render a visual representation of a red die with pips corresponding to the result of the tool call. The die should be a simple SVG. This could use the `lucide-react` library for the six faces or a custom svg.\n    *   **Weather Tool Response:** When the `getWeather` tool is called, render the weather information, including temperature and condition (sunny, cloudy, etc). Use appropriate `lucide-react` icons to represent the weather condition (e.g., `Sun`, `Cloud`, `CloudRain`). The temperature can be displayed next to the icon. Use a horizontal layout for the weather information.\n4. **Loading Indicator:** When the LLM is processing the request, there should be a simple loading indicator shown (e.g., a spinner). This can be shown using the `useTransition` hook in react.\n\nThe layout should be simple and vertical, designed to fit in a tall narrow column: Text Input, Button, Response Area. The response area will stack responses below each other as the user interacts with the bot.\n\n**Configuration:**\n\nThis demo will not have any configurable elements beyond the standard prompt the user types in. There is no need for additional configuration as the goal is to showcase the basic tool calling concept.\n\n**Server-Side API Endpoint (`api/route.ts`):**\n\n1.  **Initialization:**\n    *   Import necessary modules from Genkit, including the LLM plugin (e.g., `@genkit-ai/googleai`) and Zod for schema validation.\n    *   Initialize Genkit with a model that supports tool calling (e.g., `gemini15Flash`).\n2.  **Tool Definitions:**\n    *   **`getWeather` Tool:**\n        *   Define the tool with a `name`, `description`, `inputSchema` (location as a string), and `outputSchema` (a string).\n        *   The tool's implementation should **fake** weather data, returning a string including the temperature (a random number between 50 and 90) and condition (randomly choose from \"sunny\", \"cloudy\", \"rainy\", \"snowy\").\n    *   **`rollDice` Tool:**\n        *   Define the tool with a `name`, `description`, `inputSchema` (empty object), and `outputSchema` (a number).\n        *   The tool's implementation should return a random integer between 1 and 6.\n3.  **Route Handler Logic (POST request):**\n    *   Extract the prompt from the incoming request body.\n    *   Call `ai.generate()` with the user's prompt and both the `getWeather` and `rollDice` tools.\n    *   Send the resulting `text` from the response, and any `toolRequests` back to the client as a JSON object. The `toolRequests` array will be needed by the client to display the weather and dice properly. Note: Genkit will handle running the tools automatically, so it won't be necessary to handle `returnToolRequests` explicitly in this case.\n4.  **Response:**\n    *   Send a JSON response containing both the generated `text` and any `toolRequests`.\n\n**Important Notes:**\n\n*   No streaming is needed for this demo. A simple JSON response is sufficient.\n*   The focus is on demonstrating tool calling. The weather and dice data does not need to be dynamic.\n*   Ensure proper error handling on both the client and server-side. The `try...catch` block on the `route.ts` page should log errors.\n*   Use the shadcn/ui `Button` component, not a native `<button>`.\n*   Use the shadcn/ui `Textarea` component, not a native `<textarea>`.\n*   The demo should be visually appealing while staying simple. Use Tailwind classes for styling as necessary.\n\nThis plan provides a clear roadmap for implementing the \"Simple Tool Calling\" demo, ensuring that it effectively demonstrates the core concepts of Genkit's tool calling functionality.\n",
  "readme": "# Simple Tool Calling\n\nThis demo showcases how to use Genkit's tool calling feature. It allows an LLM to access custom functionality by calling two tools: `getWeather`, which returns fake weather data, and `rollDice`, which returns a random dice roll. The UI visualizes these tool calls with a die and weather icons.\n\n## Things to Try\n\n- Ask the chatbot about the weather.\n- Ask the chatbot to roll a die.\n- Ask the chatbot to do both in the same request.\n- Try different prompts to see how the chatbot decides which tool to use.",
  "files": [
    {
      "ext": "ts",
      "path": "api/route.ts",
      "content": "import { genkit, z } from \"genkit\";\nimport { gemini15Flash, googleAI } from \"@genkit-ai/googleai\";\nimport genkitEndpoint from \"@/lib/genkit-endpoint\";\n\nconst ai = genkit({\n  plugins: [googleAI()],\n  model: gemini15Flash,\n});\n\n// Define the getWeather tool\nconst getWeather = ai.defineTool(\n  {\n    name: \"getWeather\",\n    description: \"Gets the current weather in a given location\",\n    inputSchema: z.object({\n      location: z.string().describe(\"The location to get the current weather for\"),\n    }),\n    outputSchema: z.string(),\n  },\n  async (input) => {\n    const temperature = Math.floor(Math.random() * (90 - 50 + 1)) + 50;\n    const conditions = [\"sunny\", \"cloudy\", \"rainy\", \"snowy\"];\n    const condition = conditions[Math.floor(Math.random() * conditions.length)];\n    return `The current weather in ${input.location} is ${temperature}°F and ${condition}.`;\n  }\n);\n\n// Define the rollDice tool\nconst rollDice = ai.defineTool(\n  {\n    name: \"rollDice\",\n    description: \"Rolls a six-sided die\",\n    inputSchema: z.object({}),\n    outputSchema: z.number(),\n  },\n  async () => {\n    return Math.floor(Math.random() * 6) + 1;\n  }\n);\n\nexport const POST = genkitEndpoint(\n  { schema: z.object({ prompt: z.string() }) },\n  async ({ prompt }) => {\n    try {\n      const { text, toolRequests } = await ai.generate({\n        prompt,\n        tools: [getWeather, rollDice],\n      });\n\n      return { text, toolRequests };\n\n    } catch (error: any) {\n      console.error(\"Error during generation:\", error);\n        return {\n          error: error.message || \"An unknown error occurred.\",\n        };\n    }\n  }\n);"
    },
    {
      "ext": "tsx",
      "path": "config.tsx",
      "content": "\"use client\";\n\nexport default function SimpleToolCallingConfig() {\n  return <></>;\n}"
    },
    {
      "ext": "tsx",
      "path": "app.tsx",
      "content": "\"use client\";\nimport { useState, useTransition } from \"react\";\nimport { post } from \"@/lib/utils\";\nimport { Textarea } from \"@/components/ui/textarea\";\nimport { Button } from \"@/components/ui/button\";\nimport { Sun, Cloud, CloudRain, CloudSnow, Dice1, Dice2, Dice3, Dice4, Dice5, Dice6 } from \"lucide-react\";\nimport { cn } from \"@/lib/utils\";\n\n\ninterface ToolResponse {\n    name: string;\n    output: any;\n    ref?: string;\n}\n\ninterface ToolRequest {\n    name: string;\n    input: any;\n    ref: string;\n}\n\n\ninterface Response {\n    text?: string;\n    toolRequests?: ToolRequest[];\n    error?: string;\n}\n\n\nfunction Dice({ value }: { value: number }) {\n    let Icon;\n    switch (value) {\n        case 1:\n            Icon = Dice1;\n            break;\n        case 2:\n            Icon = Dice2;\n            break;\n        case 3:\n            Icon = Dice3;\n            break;\n        case 4:\n            Icon = Dice4;\n            break;\n        case 5:\n            Icon = Dice5;\n            break;\n        case 6:\n            Icon = Dice6;\n            break;\n        default:\n            return null;\n    }\n    return (\n        <div className=\"inline-flex items-center justify-center w-12 h-12 rounded-md bg-red-500 text-white\">\n            <Icon size={32} />\n        </div>\n    );\n}\n\nfunction Weather({ weather }: { weather: string }) {\n    const parts = weather.match(/The current weather in (.*) is (.*)°F and (.*)\\./);\n    if (!parts || parts.length !== 4) {\n        return <div>{weather}</div>;\n    }\n    const location = parts[1];\n    const temperature = parts[2];\n    const condition = parts[3];\n\n    let Icon;\n    switch (condition) {\n        case \"sunny\":\n            Icon = Sun;\n            break;\n        case \"cloudy\":\n            Icon = Cloud;\n            break;\n        case \"rainy\":\n            Icon = CloudRain;\n            break;\n        case \"snowy\":\n            Icon = CloudSnow;\n            break;\n        default:\n            return <div>{weather}</div>;\n    }\n    return (\n        <div className=\"flex items-center space-x-2\">\n            <Icon size={20} />\n            <span>{temperature}°F</span>\n            <span> in {location}</span>\n        </div>\n    );\n}\n\nexport default function SimpleToolCallingApp() {\n    const [prompt, setPrompt] = useState(\"\");\n    const [responses, setResponses] = useState<Response[]>([]);\n    const [isPending, startTransition] = useTransition();\n\n    const handleSubmit = async () => {\n        startTransition(async () => {\n            try {\n                const result = await post<{ prompt: string }, Response, Response>(\"/tool-calling-simple/api\", { prompt });\n                for await (const chunk of result) {\n                    if (chunk.error) {\n                        setResponses((prev) => [...prev, { error: chunk.error.message }]);\n                        return;\n                    }\n                    setResponses((prev) => [...prev, chunk.message]);\n                }\n            } catch (error: any) {\n                setResponses((prev) => [...prev, { error: error.message || \"An unknown error occurred.\" }]);\n                console.error(\"Error during POST request:\", error);\n            }\n        });\n    };\n\n    return (\n        <div className=\"flex flex-col w-full max-w-md space-y-4\">\n            <Textarea\n                placeholder=\"Ask a question about the weather or roll a dice!\"\n                value={prompt}\n                onChange={(e) => setPrompt(e.target.value)}\n            />\n            <Button onClick={handleSubmit} disabled={isPending}>\n                Send\n            </Button>\n            {isPending && <div className=\"text-gray-500\">Loading...</div>}\n            <div className=\"flex flex-col space-y-2\">\n                {responses.map((response, index) => (\n                    <div key={index} className=\"border rounded p-2\">\n                        {response.error && <div className=\"text-red-500\">Error: {response.error}</div>}\n                        {response.text && <div className=\"whitespace-pre-wrap\">{response.text}</div>}\n                         {response.toolRequests?.map((toolRequest, index) => {\n                            const toolResponse = response.toolRequests?.find(req => req.ref === toolRequest.ref);\n                            if (!toolResponse) return null;\n                            \n                            if (toolResponse.name === 'rollDice') {\n                                return <Dice key={index} value={toolResponse.output} />\n                            } else if (toolResponse.name === 'getWeather') {\n                                return <Weather key={index} weather={toolResponse.output} />;\n                            }\n                            return null;\n                            })\n                            }\n                    </div>\n                ))}\n            </div>\n        </div>\n    );\n}"
    },
    {
      "ext": "ts",
      "path": "page.tsx",
      "content": "import Demo from \"@/components/demo\";\nimport SimpleToolCallingConfig from \"./config\";\nimport SimpleToolCallingApp from \"./app\";\n\nexport default async function Page() {\n  return (\n    <Demo\n      name=\"tool-calling-simple\"\n      title=\"Simple Tool Calling\"\n      Config={SimpleToolCallingConfig}\n    >\n      <SimpleToolCallingApp/>\n    </Demo>\n  );\n}"
    }
  ]
}